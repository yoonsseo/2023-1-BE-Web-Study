# WIL6

1. **추상 클래스와 인터페이스**

   - 추상 클래스
       - 클래스에 '추상 메소드'가 하나 이상 포함되거나 abstract로 정의된 경우
       - 추상 클래스를 상속받아 기능을 이용하고 확장시키는 데 목적이 있다
       - 하나의 클래스만 상속 가능
   - 인터페이스
       - 모든 메소드가 추상 메소드인 경우
       - 아직 구현이 되지 않은 메소드들의 형태만 써놓아 함수의 구현을 강제해

         구현 객체의 같은 동작을 보장할 수 있다

       - final을 사용할 수 없고 인터페이스 변수들은 static이어야만 한다
       - 다중 상속 지원
       - 인터페이스를 구현한 클래스를 통한 인스턴스화가 가능하다
   - 공통점
       - 상속받는 클래스나 구현하는 인터페이스 안에 있는 추상 메소드를 구현하도록 강제한다

    
2. **static과 final 그리고 불변 객체**
    - static
        - 객체 생성 없이 사용할 수 있는 필드와 메소드를 생성하고자 할 때 활용

          인스턴스가 아니라 클래스에 속한 클래스 멤버이다

        - 필드나 메소드를 객체마다 다르게 가져야 한다면 인스턴스로 생성하면 되고

          공용 데이터나 인스턴스 필드를 포함하지 않는 메소드를 선언하고자 할 때 이용한다

        - 클래스 내부에서
            - static인 클래스 메소드에서는 클래스 변수(static 변수)만 접근 가능

              인스턴스 변수에는 접근 불가

            - static 없는 인스턴스 메소드에서는

              클래스 변수와 인스턴스 변수 모두 접근 가능

        - 클래스 외부에서
            - 클래스 변수, 클래스 메소드는 클래스 통해 접근 가능
            - 인스턴스 변수, 인스턴스 메소드는 클래스 통해 접근 불가

              반드시 인스턴스 통해서만 접근 가능

    - final
        - final 키워드는 변수(variable), 메소드(method), 또는 클래스(class)에 붙일 수 있고

          final 키워드를 붙이면 공통적으로 무언가를 **제한**한다는 의미

        - 변수에 final 붙이면 해 변수는 **수정할 수 없다**는 의미 → 초기화 값 필수

          객체 안의 변수라면 생성자, static 블럭을 통한 초기화까지는 허용

        - 메소드에 final 붙이면 **override 제한**

          상속 받은 클래스에서 해당 메소드를 수정해서 사용하지 못하도록 한다

        - final 키워드를 클래스에 붙이면 **상속 불가능**한 클래스가 된다
    - static final
        - 객체마다 저장될 필요가 없고(static) + 여러 값을 가질 수 없다(final)
        - 상수를 선언하고자 할 때 사용된다
        - final만으로 부족한가? → final로 선언하고 나중에 메소드로 초기화하는 경우

          인스턴스마다 다른 값을 가질 수 있다

        - 클래스의 모든 인스턴스에서 동일하다
    - 불변 객체(Immutable Object)
        - 객체 생성 이후 내부 상태가 변하지 않는 객체
        - read-only 메소드만 제공하고 객체의 내부 상태를 제공하는 메소드를 제공하지 않거나

          방어적 복사(defensive-copy)를 통해 제공한다

        - String
    - **불변 객체 및 final을 사용해야 하는 이유**
        - Thread-Safe하여 병렬 프로그래밍에 유용하며, 동기화를 고려하지 않아도 된다
            - 공유 자원이 불변이라면 동기화에 신경쓰지 않아도 된다
        - 실패 원자적인(Failure Atomic) 메소드를 만들 수 있다
            - 불변 객체로 작업 시 예외가 발생해도 상태를 유지할 수 있고

              예외가 발생하더라도 예외가 발생하지 않은 것처럼 처리가 가능하다

        - Cache나 Map 또는 Set 등의 요소로 활용하기에 더욱 적합하다
        - 부수 효과(Side Effect)를 피해 오류가능성을 최소화할 수 있다
            - setter를 이용해 값을 바꾸면 객체의 상태를 예측하기 어렵다
        - 다른 사람이 작성한 함수를 예측가능하고 안전하게 사용할 수 있다
        - 가비지 컬렉션의 성능을 높일 수 있다
            - 객체를 생성하기 위해서는 해당 객체를 가지는 컨테이너 객체가 존재한다는 것인데

              불변 객체가 먼저 생성되어야 컨테이너가 객체를 참조할 수 있다

              GC가 컨테이너 하위의 객체들을 skip한다

    - Java에서 불변 객체를 생성하는 방법
        1. 클래스를 final로 선언
        2. 모든 클래스 변수를 private와 final로 선언
        3. 객체를 생성하기 위한 생성자 또는 정적 팩토리 메소드를 추가
        4. 참조에 의해 변경가능성이 있는 경우 방어적 복사를 이용하여 전달