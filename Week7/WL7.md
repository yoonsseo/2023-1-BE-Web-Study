- # WIL7

- **SOLID**
    - 객체 지향 설계 및 프로그래밍의 다섯 가지 기본 원칙으로

      다섯 가지 기본 원칙의 맨 앞 알파벳을 따서 부르는 이름이다

    - 응집도는 높이고 (High Cohension), 결합도는 낮추라는 (Loose Coupling)

      고전 원칙을 객체 지향의 관점에서 재정립 한 것

      **결합도** : 모듈(클래스) 간의 상호 의존정도

      결합도가 낮으면 모듈 간의 상호 의존성이 줄어들어 객체의 재사용과 유지보수가 용이

      **응집도** : 하나의 모듈 내부에 존재하는 구성 요소들의 기능적 관련성

      응집도가 높은 모듈은 하나의 책임에 집중하고 독립성이 높아져 재사용과 유지보수에 용이


1. **단일 책임 원칙(SRP)** 의 개념과 해당 원칙이 적용되었을 때의 장점
    - Single Resposibility Principle
    - 한 클래스는 하나의 책임만 가져야 한다
    - 책임? → 중요한 기준은 **변경**

      변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것

    - 데이터베이스의 정규화 과정을 조금 더 확장해서 생각해보면

      테이블과 필드에 대한 단일 책임 원칙의 적용이라고 할 수 있다

    - 분기 처리를 위한 if문

      메소드가 단일 책임 원칙을 지키지 않을 경우 나타나는 대표적인 코드

    - 단일 책임 원칙과 가장 관계가 깊은 것은 바로 모델링 과정을 담당하는 추상화

   ex. 사람 클래스를 남자 클래스와 여자 클래스로 분할

   **공통점이 없다면 사람 클래스는 제거하고**

   **공통점이 많다면 사람 클래스를 상위 클래스로 만들기**

   ex. 남자 클래스를 역할과 책임에 따라 남자친구, 사원, 아들, 소대원 네개의 클래스로 쪼개기

   어머니-아들 관계, 상사-사원 관계, 소대장-소대원 관계는

   여자친구와 이별한 남자친구로부터 어떠한 영향도 받지 않는다

2. **개방 폐쇄 원칙(OCP)** 의 개념과 해당 원칙이 적용되었을 때의 장점
    - Open-Closed Principle
    - **확장에는 열려있지만 변경에는 닫혀있어야 한다**
    - 가장 중요한 원칙
    - 확장하려면 기존 코드를 당연히 바꾸어야 하지 않나?

      → **다형성** 활용 : 인터페이스를 구현하는 새로운 클래스 생성

    - 근데 적용하려면 어쩔 수 없이 OCP 깨짐 발생 : 클라이언트 코드 수정 필요

      → 객체를 생성하고 연관 관계를 맺어주는 별도의 조립 설정자 필요 = 스프링 컨테이너

    ex. 운전자와 마티즈 또는 쏘나타의 관계에서 
    
    자동차라는 **상위 클래스 또는 인터페이스를 중간에 둠으로써** 다양한 자동차가 생긴다고 해도 
    
    객체 지향 세계의 운전자는 운전 습관에 영향을 받지 않게 된다 
    
    자동차는 자신의 확장에 개방되어 있고, 운전자는 주변의 변화에 폐쇄되어 있다
    
    ex. JDBC를 사용하는 클라이언트는 데이터베이스가 오라클에서 MySQL로 바뀌더라도 
    
    커넥션을 설정하는 부분 외에는 따로 수정할 필요가 없다
    
    ex. JAVA 개발자는 각 운영체제 별 JVM과 목적 파일(.class)이 있기 때문에 
    
    다양한 구동 환경에 대해 걱정하지 않아도 된다 
    
    ex. 구매 담당 직원, 보안 담당 직원, 청소 담당 직원, 편의점 사장은 모두 
    
    판매 인터페이스를 상속받기 때문에 손님의 구매 행위는 영향을 받지 않는다
    
    - 유연성, 재사용성, 유지보수에 용이하다

    
3. **리스코프 치환 원칙(LSP)** 의 개념과 해당 원칙이 적용되었을 때의 장점
    - Liscov Substitution Principle
    - 서브 타입은 언제나 자신의 기반 타입으로 교체할 수 있어야 한다
    - 객체 지향에서의 상속은 조직도나 계층도가 아닌 **분류도**가 되어야 한다
        - 하위 클래스 is a kind of 상위 클래스
        - 구현 클래스 is able to 인터페이스

      → 이 둘을 잘 지킨다면 LSP 만족

    - **하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해**

      **상위 클래스의 인스턴스 역할을 하는 데 문제가 없어야 한다**

    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서

      하위 타입의 인스턴스로 바꿀 수 있어야 한다

    - 상속 구조가 분류도인 경우 하위에 존재하는 것들은

      상위에 있는 것들의 역할을 하는 데 전혀 문제가 없다 : 동물 - 조류 - 펭귄

    - 악셀을 밟으면 앞으로 가야한다는 규약에서

      악셀을 밟아도 -10으로 가도록 구현해도 컴파일은 되지만

      컴파일 단위를 말하는 게 아님

      **규약을 맞춰야 한다 : 기능적으로 보장**


4. **인터페이스 분리 원칙(ISP)** 의 개념과 해당 원칙이 적용되었을 때의 장점
    - Interface Segregation Principle
    - **클라이언트는 자신이 사용하지 않는 메소드에 의존 관계를 맺으면 안 된다**
    - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다

   ex. 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리

   사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트로 분리

    - 기능을 적당한 크기로 쪼개는 게 중요하다
    - SRP와 ISP는 같은 문제에 대한 두 가지 다른 해결책이라고 볼 수 있다
    - 안터페이스 최소주의 원칙

      인터페이스를 통해 메소드를 외부에 제공할 때는 최소한의 메소드만 제공

    - 상위 클래스는 풍성할수록 좋고, 인터페이스는 작을수록 좋다

      LSP에 따라 하위 객체는 상위 객체인 척 할 수 있는데

        - 빈약한 상위 클래스를 이용한 경우 빈번하게 형변환이 발생하면서

          상속의 혜택을 제대로 누리지 못할 수 있다

          사람 - 이름 / 먹다()

          학생 -  생일, 주민등록번호, 학번 / 자다(), 소개하다(), 공부하다()

          군인 - 생일, 주민등록번호, 군번 / 자다(), 소개하다(), 훈련하다()

            ```java
            사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), 
            		"000101-1234567", "C035987");
            사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), 
            		"981231-1234567", "19-12345678");
            
            System.out.println(김학생.이름);
            System.out.println(이군인.이름);
            
            //System.out.println(김학생.생일);
            //System.out.println(이군인.생일);
            
            System.out.println(**((학생) 김학생).생일**);
            System.out.println(**((군인) 이군인).주민등록번호**);
            
            김학생.먹다();
            ((학생) 김학생).자다();
            ((학생) 김학생).소개하다();
            ((군인) 이군인).소개하다();
            ((군인) 이군인).훈련하다();
            ```

        - 풍성한 상위 클래스를 이용하는 경우 사용 불가능한 경우나 불필요한 형변환이 없다

          사람 - 이름, 생일, 주민등록번호 / 먹다(), 자다(), 소개하다()

          학생 - 학번 / 공부하다()

          군인 - 군번 / 훈련하다()

          학생과 군인의 소개 내용은 다르겠지만 ‘소개하다’ 라는 기능은 필요 → 추상 메소드

            ```java
            사람 김학생 = new 학생("김학생", new Date(2000, 01, 01), 
            		"000101-1234567", "C035987");
            사람 이군인 = new 군인("이군인", new Date(1998, 12, 31), 
            		"981231-1234567", "19-12345678");
            
            System.out.println(김학생.이름);
            System.out.println(이군인.이름);
            
            System.out.println(김학생.생일);
            System.out.println(이군인.생일);
            
            //System.out.println(((학생) 김학생).생일);
            //System.out.println(((군인) 이군인).주민등록번호);
            
            System.out.println(**((학생) 김학생).학번**);
            System.out.println(**((군인) 이군인).군번**);
            
            김학생.먹다();
            이군인.자다();
            김학생.소개하다();
            이군인.소개하다();
            
            ((학생) 김학생).공부하다();
            ((군인) 이군인).훈련하다();
            ```

5. **의존 역전 원칙(DIP)** 의 개념과 해당 원칙이 적용되었을 때의 장점
    - Dependency Inversion Principle
    - 고차원 모듈은 저차원 모듈에 의존하면 안 된다

      이 두 모듈 모두 다른 추상화된 것에 의존해야 한다

    - **추상화된 것은 구체적인 것에 의존하면 안 된다.**

      **구체적인 것이 추상화된 것에 의존해야 한다**

    - 자주 변경되는 구체 클래스에 의존하지 마라

   ex. 자동차가 일반 타이어, 스노우 타이어가 아닌 타이어 인터페이스에 의존하도록 설정

   → 의존의 방향 역전 : **자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위**

   **클래스를 두어 변하기 쉬운 것의 변화에 영향받지 않게 하는 것이 의존 역전 원칙**

    - 프로그래머는 “**추상화에 의존해야지, 구체화에 의존하면 안된다**.”

      의존성 주입은 이 원칙을 따르는 방법 중 하나다

    - OCP와 함께 가장 중요한 원칙
    - 클라이언트 코드가 구현 코드 클래스가 아니라 인터페이스만 봐야한다
    - 앞에서 이야기한 **역할(Role)에 의존**하게 해야 한다는 것과 같다
    - 그런데 OCP에서 설명한 MemberService는 인터페이스에 의존하지만,

      구현 클래스도 동시에 의존

      멤버 서비스는 멤버 리포지토리 필드를 가지고 있고

      여기에 메모리 멤버 리포지토리 할당

      그러면 멤버 서비스는 메모리 멤버 리포지토리에도 의존하고 있는 것

        - 의존한다?

          내가 저 코드를 안다

        멤버 서비스는 멤버 리포지토리 인터페이스만 아는 게 아니라
        
        메모리 멤버 리포지토리까지 알고 있는 것
        
        메모리 멤버 리포지토리를 다른 걸로 바꾸려고 할 때 코드 바꿔야 한다
        
        클라이언트가 구현 클래스 직접 선택
        
        인터페이스와 구현 클래스 동시에 의존
        
        → DIP 위반
